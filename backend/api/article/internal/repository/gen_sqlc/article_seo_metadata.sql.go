// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: article_seo_metadata.sql

package gen_sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createArticleSEOMetadata = `-- name: CreateArticleSEOMetadata :one
INSERT INTO "article_seo_metadata" (
    "article_id",
    "description",
    "keywords",
    "og_image"
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING article_id, description, keywords, og_image, created_at, updated_at
`

type CreateArticleSEOMetadataParams struct {
	ArticleID   uuid.UUID      `json:"article_id"`
	Description sql.NullString `json:"description"`
	Keywords    []string       `json:"keywords"`
	OgImage     sql.NullString `json:"og_image"`
}

func (q *Queries) CreateArticleSEOMetadata(ctx context.Context, db DBTX, arg CreateArticleSEOMetadataParams) (ArticleSeoMetadatum, error) {
	row := db.QueryRowContext(ctx, createArticleSEOMetadata,
		arg.ArticleID,
		arg.Description,
		pq.Array(arg.Keywords),
		arg.OgImage,
	)
	var i ArticleSeoMetadatum
	err := row.Scan(
		&i.ArticleID,
		&i.Description,
		pq.Array(&i.Keywords),
		&i.OgImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteArticleSEOMetadata = `-- name: DeleteArticleSEOMetadata :exec
DELETE FROM "article_seo_metadata"
WHERE "article_id" = $1
`

func (q *Queries) DeleteArticleSEOMetadata(ctx context.Context, db DBTX, articleID uuid.UUID) error {
	_, err := db.ExecContext(ctx, deleteArticleSEOMetadata, articleID)
	return err
}

const getArticleSEOMetadata = `-- name: GetArticleSEOMetadata :one
SELECT article_id, description, keywords, og_image, created_at, updated_at FROM "article_seo_metadata"
WHERE "article_id" = $1
`

func (q *Queries) GetArticleSEOMetadata(ctx context.Context, db DBTX, articleID uuid.UUID) (ArticleSeoMetadatum, error) {
	row := db.QueryRowContext(ctx, getArticleSEOMetadata, articleID)
	var i ArticleSeoMetadatum
	err := row.Scan(
		&i.ArticleID,
		&i.Description,
		pq.Array(&i.Keywords),
		&i.OgImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listArticlesWithSEOMetadata = `-- name: ListArticlesWithSEOMetadata :many
SELECT
    a.id, a.title, a.content, a.slug, a.summary, a.status, a.category_id, a.view_count, a.published_at, a.created_at, a.updated_at,
    "sm"."description" AS "seo_description",
    "sm"."keywords" AS "seo_keywords",
    "sm"."og_image" AS "seo_og_image"
FROM "articles" "a"
LEFT JOIN "article_seo_metadata" "sm" ON "a"."id" = "sm"."article_id"
WHERE "a"."status" = 'published'
ORDER BY "a"."published_at" DESC
LIMIT $2 OFFSET $1
`

type ListArticlesWithSEOMetadataParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListArticlesWithSEOMetadataRow struct {
	ID             uuid.UUID      `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	Slug           string         `json:"slug"`
	Summary        sql.NullString `json:"summary"`
	Status         string         `json:"status"`
	CategoryID     uuid.NullUUID  `json:"category_id"`
	ViewCount      sql.NullInt32  `json:"view_count"`
	PublishedAt    sql.NullTime   `json:"published_at"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	SeoDescription sql.NullString `json:"seo_description"`
	SeoKeywords    []string       `json:"seo_keywords"`
	SeoOgImage     sql.NullString `json:"seo_og_image"`
}

func (q *Queries) ListArticlesWithSEOMetadata(ctx context.Context, db DBTX, arg ListArticlesWithSEOMetadataParams) ([]ListArticlesWithSEOMetadataRow, error) {
	rows, err := db.QueryContext(ctx, listArticlesWithSEOMetadata, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArticlesWithSEOMetadataRow
	for rows.Next() {
		var i ListArticlesWithSEOMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeoDescription,
			pq.Array(&i.SeoKeywords),
			&i.SeoOgImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticleSEOMetadata = `-- name: UpdateArticleSEOMetadata :one
UPDATE "article_seo_metadata"
SET
    "description" = $1,
    "keywords" = $2,
    "og_image" = $3,
    "updated_at" = CURRENT_TIMESTAMP
WHERE "article_id" = $4
RETURNING article_id, description, keywords, og_image, created_at, updated_at
`

type UpdateArticleSEOMetadataParams struct {
	Description sql.NullString `json:"description"`
	Keywords    []string       `json:"keywords"`
	OgImage     sql.NullString `json:"og_image"`
	ArticleID   uuid.UUID      `json:"article_id"`
}

func (q *Queries) UpdateArticleSEOMetadata(ctx context.Context, db DBTX, arg UpdateArticleSEOMetadataParams) (ArticleSeoMetadatum, error) {
	row := db.QueryRowContext(ctx, updateArticleSEOMetadata,
		arg.Description,
		pq.Array(arg.Keywords),
		arg.OgImage,
		arg.ArticleID,
	)
	var i ArticleSeoMetadatum
	err := row.Scan(
		&i.ArticleID,
		&i.Description,
		pq.Array(&i.Keywords),
		&i.OgImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertArticleSEOMetadata = `-- name: UpsertArticleSEOMetadata :one
INSERT INTO "article_seo_metadata" (
    "article_id",
    "description",
    "keywords",
    "og_image"
) VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT ("article_id") DO UPDATE
SET
    "description" = EXCLUDED."description",
    "keywords" = EXCLUDED."keywords",
    "og_image" = EXCLUDED."og_image",
    "updated_at" = CURRENT_TIMESTAMP
RETURNING article_id, description, keywords, og_image, created_at, updated_at
`

type UpsertArticleSEOMetadataParams struct {
	ArticleID   uuid.UUID      `json:"article_id"`
	Description sql.NullString `json:"description"`
	Keywords    []string       `json:"keywords"`
	OgImage     sql.NullString `json:"og_image"`
}

func (q *Queries) UpsertArticleSEOMetadata(ctx context.Context, db DBTX, arg UpsertArticleSEOMetadataParams) (ArticleSeoMetadatum, error) {
	row := db.QueryRowContext(ctx, upsertArticleSEOMetadata,
		arg.ArticleID,
		arg.Description,
		pq.Array(arg.Keywords),
		arg.OgImage,
	)
	var i ArticleSeoMetadatum
	err := row.Scan(
		&i.ArticleID,
		&i.Description,
		pq.Array(&i.Keywords),
		&i.OgImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
