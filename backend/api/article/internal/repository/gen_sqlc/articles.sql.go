// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: articles.sql

package gen_sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countArticles = `-- name: CountArticles :one
SELECT COUNT(*) FROM "articles"
WHERE "status" = 'published'
`

func (q *Queries) CountArticles(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, countArticles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countArticlesByCategory = `-- name: CountArticlesByCategory :one
SELECT COUNT(*) FROM "articles"
WHERE "category_id" = $1 AND "status" = 'published'
`

func (q *Queries) CountArticlesByCategory(ctx context.Context, db DBTX, categoryID uuid.NullUUID) (int64, error) {
	row := db.QueryRowContext(ctx, countArticlesByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countArticlesByMonth = `-- name: CountArticlesByMonth :one
SELECT COUNT(*) FROM "articles"
WHERE "status" = 'published'
  AND EXTRACT(YEAR FROM "published_at") = $1
  AND EXTRACT(MONTH FROM "published_at") = $2
`

type CountArticlesByMonthParams struct {
	Year  sql.NullTime `json:"year"`
	Month sql.NullTime `json:"month"`
}

func (q *Queries) CountArticlesByMonth(ctx context.Context, db DBTX, arg CountArticlesByMonthParams) (int64, error) {
	row := db.QueryRowContext(ctx, countArticlesByMonth, arg.Year, arg.Month)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchArticles = `-- name: CountSearchArticles :one
SELECT COUNT(*) FROM "articles"
WHERE "status" = 'published'
  AND (
    "title" ILIKE '%' || $1 || '%' OR
    "content" ILIKE '%' || $1 || '%' OR
    "summary" ILIKE '%' || $1 || '%'
  )
`

func (q *Queries) CountSearchArticles(ctx context.Context, db DBTX, query sql.NullString) (int64, error) {
	row := db.QueryRowContext(ctx, countSearchArticles, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO "articles" (
    "title", "content", "slug", "summary", "status", "category_id", "published_at"
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7
) RETURNING id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at
`

type CreateArticleParams struct {
	Title       string         `json:"title"`
	Content     string         `json:"content"`
	Slug        string         `json:"slug"`
	Summary     sql.NullString `json:"summary"`
	Status      string         `json:"status"`
	CategoryID  uuid.NullUUID  `json:"category_id"`
	PublishedAt sql.NullTime   `json:"published_at"`
}

func (q *Queries) CreateArticle(ctx context.Context, db DBTX, arg CreateArticleParams) (Article, error) {
	row := db.QueryRowContext(ctx, createArticle,
		arg.Title,
		arg.Content,
		arg.Slug,
		arg.Summary,
		arg.Status,
		arg.CategoryID,
		arg.PublishedAt,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM "articles"
WHERE "id" = $1
`

func (q *Queries) DeleteArticle(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.ExecContext(ctx, deleteArticle, id)
	return err
}

const getArticle = `-- name: GetArticle :one
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "id" = $1
`

func (q *Queries) GetArticle(ctx context.Context, db DBTX, id uuid.UUID) (Article, error) {
	row := db.QueryRowContext(ctx, getArticle, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getArticleBySlug = `-- name: GetArticleBySlug :one
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "slug" = $1
`

func (q *Queries) GetArticleBySlug(ctx context.Context, db DBTX, slug string) (Article, error) {
	row := db.QueryRowContext(ctx, getArticleBySlug, slug)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementArticleViewCount = `-- name: IncrementArticleViewCount :exec
UPDATE "articles"
SET "view_count" = "view_count" + 1
WHERE "id" = $1
`

func (q *Queries) IncrementArticleViewCount(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.ExecContext(ctx, incrementArticleViewCount, id)
	return err
}

const listArticles = `-- name: ListArticles :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "status" = 'published'
ORDER BY "published_at" DESC
LIMIT $2 OFFSET $1
`

type ListArticlesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListArticles(ctx context.Context, db DBTX, arg ListArticlesParams) ([]Article, error) {
	rows, err := db.QueryContext(ctx, listArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByCategory = `-- name: ListArticlesByCategory :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "category_id" = $1 AND "status" = 'published'
ORDER BY "published_at" DESC
LIMIT $3 OFFSET $2
`

type ListArticlesByCategoryParams struct {
	CategoryID uuid.NullUUID `json:"category_id"`
	Offset     int32         `json:"offset"`
	Limit      int32         `json:"limit"`
}

func (q *Queries) ListArticlesByCategory(ctx context.Context, db DBTX, arg ListArticlesByCategoryParams) ([]Article, error) {
	rows, err := db.QueryContext(ctx, listArticlesByCategory, arg.CategoryID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByMonth = `-- name: ListArticlesByMonth :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "status" = 'published'
  AND EXTRACT(YEAR FROM "published_at") = $1
  AND EXTRACT(MONTH FROM "published_at") = $2
ORDER BY "published_at" DESC
LIMIT $4 OFFSET $3
`

type ListArticlesByMonthParams struct {
	Year   sql.NullTime `json:"year"`
	Month  sql.NullTime `json:"month"`
	Offset int32        `json:"offset"`
	Limit  int32        `json:"limit"`
}

func (q *Queries) ListArticlesByMonth(ctx context.Context, db DBTX, arg ListArticlesByMonthParams) ([]Article, error) {
	rows, err := db.QueryContext(ctx, listArticlesByMonth,
		arg.Year,
		arg.Month,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByStatus = `-- name: ListArticlesByStatus :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "status" = $1
ORDER BY "created_at" DESC
LIMIT $3 OFFSET $2
`

type ListArticlesByStatusParams struct {
	Status string `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) ListArticlesByStatus(ctx context.Context, db DBTX, arg ListArticlesByStatusParams) ([]Article, error) {
	rows, err := db.QueryContext(ctx, listArticlesByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPopularArticles = `-- name: ListPopularArticles :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "status" = 'published' AND "view_count" > 0
ORDER BY "view_count" DESC
LIMIT $1
`

func (q *Queries) ListPopularArticles(ctx context.Context, db DBTX, limit int32) ([]Article, error) {
	rows, err := db.QueryContext(ctx, listPopularArticles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentArticles = `-- name: ListRecentArticles :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "status" = 'published'
ORDER BY "published_at" DESC
LIMIT $1
`

func (q *Queries) ListRecentArticles(ctx context.Context, db DBTX, limit int32) ([]Article, error) {
	rows, err := db.QueryContext(ctx, listRecentArticles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchArticles = `-- name: SearchArticles :many
SELECT id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at FROM "articles"
WHERE "status" = 'published'
  AND (
    "title" ILIKE '%' || $1 || '%' OR
    "content" ILIKE '%' || $1 || '%' OR
    "summary" ILIKE '%' || $1 || '%'
  )
ORDER BY "published_at" DESC
LIMIT $3 OFFSET $2
`

type SearchArticlesParams struct {
	Query  sql.NullString `json:"query"`
	Offset int32          `json:"offset"`
	Limit  int32          `json:"limit"`
}

func (q *Queries) SearchArticles(ctx context.Context, db DBTX, arg SearchArticlesParams) ([]Article, error) {
	rows, err := db.QueryContext(ctx, searchArticles, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE "articles"
SET
    "title" = $1,
    "content" = $2,
    "slug" = $3,
    "summary" = $4,
    "status" = $5,
    "category_id" = $6,
    "published_at" = $7,
    "updated_at" = CURRENT_TIMESTAMP
WHERE "id" = $8
RETURNING id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at
`

type UpdateArticleParams struct {
	Title       string         `json:"title"`
	Content     string         `json:"content"`
	Slug        string         `json:"slug"`
	Summary     sql.NullString `json:"summary"`
	Status      string         `json:"status"`
	CategoryID  uuid.NullUUID  `json:"category_id"`
	PublishedAt sql.NullTime   `json:"published_at"`
	ID          uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateArticle(ctx context.Context, db DBTX, arg UpdateArticleParams) (Article, error) {
	row := db.QueryRowContext(ctx, updateArticle,
		arg.Title,
		arg.Content,
		arg.Slug,
		arg.Summary,
		arg.Status,
		arg.CategoryID,
		arg.PublishedAt,
		arg.ID,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateArticleStatus = `-- name: UpdateArticleStatus :one
UPDATE "articles"
SET
    "status" = $1,
    "published_at" = CASE
        WHEN $1 = 'published' AND "published_at" IS NULL THEN CURRENT_TIMESTAMP
        ELSE "published_at"
    END,
    "updated_at" = CURRENT_TIMESTAMP
WHERE "id" = $2
RETURNING id, title, content, slug, summary, status, category_id, view_count, published_at, created_at, updated_at
`

type UpdateArticleStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateArticleStatus(ctx context.Context, db DBTX, arg UpdateArticleStatusParams) (Article, error) {
	row := db.QueryRowContext(ctx, updateArticleStatus, arg.Status, arg.ID)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
