// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: article_with_relations.sql

package gen_sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getArticleBySlugWithRelations = `-- name: GetArticleBySlugWithRelations :one
SELECT
    a.id, a.title, a.content, a.slug, a.summary, a.status, a.category_id, a.view_count, a.published_at, a.created_at, a.updated_at,
    "c"."name" AS "category_name",
    "c"."slug" AS "category_slug",
    "sm"."description" AS "seo_description",
    "sm"."keywords" AS "seo_keywords",
    "sm"."og_image" AS "seo_og_image"
FROM "articles" "a"
LEFT JOIN "categories" "c" ON "a"."category_id" = "c"."id"
LEFT JOIN "article_seo_metadata" "sm" ON "a"."id" = "sm"."article_id"
WHERE "a"."slug" = $1
`

type GetArticleBySlugWithRelationsRow struct {
	ID             uuid.UUID      `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	Slug           string         `json:"slug"`
	Summary        sql.NullString `json:"summary"`
	Status         string         `json:"status"`
	CategoryID     uuid.NullUUID  `json:"category_id"`
	ViewCount      sql.NullInt32  `json:"view_count"`
	PublishedAt    sql.NullTime   `json:"published_at"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	CategoryName   sql.NullString `json:"category_name"`
	CategorySlug   sql.NullString `json:"category_slug"`
	SeoDescription sql.NullString `json:"seo_description"`
	SeoKeywords    []string       `json:"seo_keywords"`
	SeoOgImage     sql.NullString `json:"seo_og_image"`
}

func (q *Queries) GetArticleBySlugWithRelations(ctx context.Context, db DBTX, slug string) (GetArticleBySlugWithRelationsRow, error) {
	row := db.QueryRowContext(ctx, getArticleBySlugWithRelations, slug)
	var i GetArticleBySlugWithRelationsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.CategorySlug,
		&i.SeoDescription,
		pq.Array(&i.SeoKeywords),
		&i.SeoOgImage,
	)
	return i, err
}

const getArticleWithRelations = `-- name: GetArticleWithRelations :one
SELECT
    a.id, a.title, a.content, a.slug, a.summary, a.status, a.category_id, a.view_count, a.published_at, a.created_at, a.updated_at,
    "c"."name" AS "category_name",
    "c"."slug" AS "category_slug",
    "sm"."description" AS "seo_description",
    "sm"."keywords" AS "seo_keywords",
    "sm"."og_image" AS "seo_og_image"
FROM "articles" "a"
LEFT JOIN "categories" "c" ON "a"."category_id" = "c"."id"
LEFT JOIN "article_seo_metadata" "sm" ON "a"."id" = "sm"."article_id"
WHERE "a"."id" = $1
`

type GetArticleWithRelationsRow struct {
	ID             uuid.UUID      `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	Slug           string         `json:"slug"`
	Summary        sql.NullString `json:"summary"`
	Status         string         `json:"status"`
	CategoryID     uuid.NullUUID  `json:"category_id"`
	ViewCount      sql.NullInt32  `json:"view_count"`
	PublishedAt    sql.NullTime   `json:"published_at"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	CategoryName   sql.NullString `json:"category_name"`
	CategorySlug   sql.NullString `json:"category_slug"`
	SeoDescription sql.NullString `json:"seo_description"`
	SeoKeywords    []string       `json:"seo_keywords"`
	SeoOgImage     sql.NullString `json:"seo_og_image"`
}

func (q *Queries) GetArticleWithRelations(ctx context.Context, db DBTX, id uuid.UUID) (GetArticleWithRelationsRow, error) {
	row := db.QueryRowContext(ctx, getArticleWithRelations, id)
	var i GetArticleWithRelationsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Slug,
		&i.Summary,
		&i.Status,
		&i.CategoryID,
		&i.ViewCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.CategorySlug,
		&i.SeoDescription,
		pq.Array(&i.SeoKeywords),
		&i.SeoOgImage,
	)
	return i, err
}

const getArticleWithTags = `-- name: GetArticleWithTags :many
SELECT
    a.id, a.title, a.content, a.slug, a.summary, a.status, a.category_id, a.view_count, a.published_at, a.created_at, a.updated_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', "t"."id",
                'name', "t"."name",
                'slug', "t"."slug"
            ) ORDER BY "t"."name"
        ) FILTER (WHERE "t"."id" IS NOT NULL),
        '[]'::json
    ) AS "tags"
FROM "articles" "a"
LEFT JOIN "article_tags" "at" ON "a"."id" = "at"."article_id"
LEFT JOIN "tags" "t" ON "at"."tag_id" = "t"."id"
WHERE "a"."id" = $1
GROUP BY "a"."id"
`

type GetArticleWithTagsRow struct {
	ID          uuid.UUID      `json:"id"`
	Title       string         `json:"title"`
	Content     string         `json:"content"`
	Slug        string         `json:"slug"`
	Summary     sql.NullString `json:"summary"`
	Status      string         `json:"status"`
	CategoryID  uuid.NullUUID  `json:"category_id"`
	ViewCount   sql.NullInt32  `json:"view_count"`
	PublishedAt sql.NullTime   `json:"published_at"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	Tags        interface{}    `json:"tags"`
}

func (q *Queries) GetArticleWithTags(ctx context.Context, db DBTX, id uuid.UUID) ([]GetArticleWithTagsRow, error) {
	rows, err := db.QueryContext(ctx, getArticleWithTags, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticleWithTagsRow
	for rows.Next() {
		var i GetArticleWithTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesWithAllRelations = `-- name: ListArticlesWithAllRelations :many
SELECT
    a.id, a.title, a.content, a.slug, a.summary, a.status, a.category_id, a.view_count, a.published_at, a.created_at, a.updated_at,
    "c"."name" AS "category_name",
    "c"."slug" AS "category_slug",
    "sm"."description" AS "seo_description",
    "sm"."keywords" AS "seo_keywords",
    "sm"."og_image" AS "seo_og_image",
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', "t"."id",
                'name', "t"."name",
                'slug', "t"."slug"
            )
        ) FILTER (WHERE "t"."id" IS NOT NULL),
        '[]'::json
    ) AS "tags"
FROM "articles" "a"
LEFT JOIN "categories" "c" ON "a"."category_id" = "c"."id"
LEFT JOIN "article_seo_metadata" "sm" ON "a"."id" = "sm"."article_id"
LEFT JOIN "article_tags" "at" ON "a"."id" = "at"."article_id"
LEFT JOIN "tags" "t" ON "at"."tag_id" = "t"."id"
WHERE "a"."status" = 'published'
GROUP BY "a"."id", "c"."name", "c"."slug", "sm"."description", "sm"."keywords", "sm"."og_image"
ORDER BY "a"."published_at" DESC
LIMIT $2 OFFSET $1
`

type ListArticlesWithAllRelationsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListArticlesWithAllRelationsRow struct {
	ID             uuid.UUID      `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	Slug           string         `json:"slug"`
	Summary        sql.NullString `json:"summary"`
	Status         string         `json:"status"`
	CategoryID     uuid.NullUUID  `json:"category_id"`
	ViewCount      sql.NullInt32  `json:"view_count"`
	PublishedAt    sql.NullTime   `json:"published_at"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	CategoryName   sql.NullString `json:"category_name"`
	CategorySlug   sql.NullString `json:"category_slug"`
	SeoDescription sql.NullString `json:"seo_description"`
	SeoKeywords    []string       `json:"seo_keywords"`
	SeoOgImage     sql.NullString `json:"seo_og_image"`
	Tags           interface{}    `json:"tags"`
}

func (q *Queries) ListArticlesWithAllRelations(ctx context.Context, db DBTX, arg ListArticlesWithAllRelationsParams) ([]ListArticlesWithAllRelationsRow, error) {
	rows, err := db.QueryContext(ctx, listArticlesWithAllRelations, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArticlesWithAllRelationsRow
	for rows.Next() {
		var i ListArticlesWithAllRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.SeoDescription,
			pq.Array(&i.SeoKeywords),
			&i.SeoOgImage,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesWithCategory = `-- name: ListArticlesWithCategory :many
SELECT
    a.id, a.title, a.content, a.slug, a.summary, a.status, a.category_id, a.view_count, a.published_at, a.created_at, a.updated_at,
    "c"."name" AS "category_name",
    "c"."slug" AS "category_slug"
FROM "articles" "a"
LEFT JOIN "categories" "c" ON "a"."category_id" = "c"."id"
WHERE "a"."status" = 'published'
ORDER BY "a"."published_at" DESC
LIMIT $2 OFFSET $1
`

type ListArticlesWithCategoryParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListArticlesWithCategoryRow struct {
	ID           uuid.UUID      `json:"id"`
	Title        string         `json:"title"`
	Content      string         `json:"content"`
	Slug         string         `json:"slug"`
	Summary      sql.NullString `json:"summary"`
	Status       string         `json:"status"`
	CategoryID   uuid.NullUUID  `json:"category_id"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) ListArticlesWithCategory(ctx context.Context, db DBTX, arg ListArticlesWithCategoryParams) ([]ListArticlesWithCategoryRow, error) {
	rows, err := db.QueryContext(ctx, listArticlesWithCategory, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArticlesWithCategoryRow
	for rows.Next() {
		var i ListArticlesWithCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Slug,
			&i.Summary,
			&i.Status,
			&i.CategoryID,
			&i.ViewCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
